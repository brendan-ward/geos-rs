/* automatically generated by rust-bindgen 0.60.1 */

pub const GEOS_VERSION_MAJOR: u32 = 3;
pub const GEOS_VERSION_MINOR: u32 = 9;
pub const GEOS_VERSION_PATCH: u32 = 3;
pub const GEOS_VERSION: &[u8; 6usize] = b"3.9.3\0";
pub const GEOS_JTS_PORT: &[u8; 7usize] = b"1.17.0\0";
pub const GEOS_CAPI_VERSION_MAJOR: u32 = 1;
pub const GEOS_CAPI_VERSION_MINOR: u32 = 14;
pub const GEOS_CAPI_VERSION_PATCH: u32 = 3;
pub const GEOS_CAPI_VERSION: &[u8; 18usize] = b"3.9.3-CAPI-1.14.3\0";
pub const GEOS_CAPI_FIRST_INTERFACE: u32 = 1;
pub const GEOS_CAPI_LAST_INTERFACE: u32 = 15;
pub const GEOS_PREC_NO_TOPO: u32 = 1;
pub const GEOS_PREC_KEEP_COLLAPSED: u32 = 2;
pub type wchar_t = libc::c_int;
pub type max_align_t = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSContextHandle_HS {
    _unused: [u8; 0],
}
#[doc = " (Abstract) type definitions"]
#[doc = ""]
pub type GEOSContextHandle_t = *mut GEOSContextHandle_HS;
pub type GEOSMessageHandler =
    ::std::option::Option<unsafe extern "C" fn(fmt: *const libc::c_char, ...)>;
pub type GEOSMessageHandler_r = ::std::option::Option<
    unsafe extern "C" fn(message: *const libc::c_char, userdata: *mut libc::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSGeom_t {
    _unused: [u8; 0],
}
pub type GEOSGeometry = GEOSGeom_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSPrepGeom_t {
    _unused: [u8; 0],
}
pub type GEOSPreparedGeometry = GEOSPrepGeom_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSCoordSeq_t {
    _unused: [u8; 0],
}
pub type GEOSCoordSequence = GEOSCoordSeq_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSSTRtree_t {
    _unused: [u8; 0],
}
pub type GEOSSTRtree = GEOSSTRtree_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSBufParams_t {
    _unused: [u8; 0],
}
pub type GEOSBufferParams = GEOSBufParams_t;
pub type GEOSGeom = *mut GEOSGeometry;
pub type GEOSCoordSeq = *mut GEOSCoordSequence;
pub const GEOSGeomTypes_GEOS_POINT: GEOSGeomTypes = 0;
pub const GEOSGeomTypes_GEOS_LINESTRING: GEOSGeomTypes = 1;
pub const GEOSGeomTypes_GEOS_LINEARRING: GEOSGeomTypes = 2;
pub const GEOSGeomTypes_GEOS_POLYGON: GEOSGeomTypes = 3;
pub const GEOSGeomTypes_GEOS_MULTIPOINT: GEOSGeomTypes = 4;
pub const GEOSGeomTypes_GEOS_MULTILINESTRING: GEOSGeomTypes = 5;
pub const GEOSGeomTypes_GEOS_MULTIPOLYGON: GEOSGeomTypes = 6;
pub const GEOSGeomTypes_GEOS_GEOMETRYCOLLECTION: GEOSGeomTypes = 7;
pub type GEOSGeomTypes = libc::c_uint;
pub const GEOSByteOrders_GEOS_WKB_XDR: GEOSByteOrders = 0;
pub const GEOSByteOrders_GEOS_WKB_NDR: GEOSByteOrders = 1;
pub type GEOSByteOrders = libc::c_uint;
pub type GEOSQueryCallback = ::std::option::Option<
    unsafe extern "C" fn(item: *mut libc::c_void, userdata: *mut libc::c_void),
>;
pub type GEOSDistanceCallback = ::std::option::Option<
    unsafe extern "C" fn(
        item1: *const libc::c_void,
        item2: *const libc::c_void,
        distance: *mut f64,
        userdata: *mut libc::c_void,
    ) -> libc::c_int,
>;
pub type GEOSInterruptCallback = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn GEOS_interruptRegisterCallback(cb: GEOSInterruptCallback) -> GEOSInterruptCallback;
}
extern "C" {
    pub fn GEOS_interruptRequest();
}
extern "C" {
    pub fn GEOS_interruptCancel();
}
extern "C" {
    pub fn GEOS_init_r() -> GEOSContextHandle_t;
}
extern "C" {
    pub fn GEOS_finish_r(handle: GEOSContextHandle_t);
}
extern "C" {
    pub fn GEOSContext_setNoticeHandler_r(
        extHandle: GEOSContextHandle_t,
        nf: GEOSMessageHandler,
    ) -> GEOSMessageHandler;
}
extern "C" {
    pub fn GEOSContext_setErrorHandler_r(
        extHandle: GEOSContextHandle_t,
        ef: GEOSMessageHandler,
    ) -> GEOSMessageHandler;
}
extern "C" {
    pub fn GEOSContext_setNoticeMessageHandler_r(
        extHandle: GEOSContextHandle_t,
        nf: GEOSMessageHandler_r,
        userData: *mut libc::c_void,
    ) -> GEOSMessageHandler_r;
}
extern "C" {
    pub fn GEOSContext_setErrorMessageHandler_r(
        extHandle: GEOSContextHandle_t,
        ef: GEOSMessageHandler_r,
        userData: *mut libc::c_void,
    ) -> GEOSMessageHandler_r;
}
extern "C" {
    pub fn GEOSversion() -> *const libc::c_char;
}
extern "C" {
    pub fn GEOS_getWKBOutputDims_r(handle: GEOSContextHandle_t) -> libc::c_int;
}
extern "C" {
    pub fn GEOS_setWKBOutputDims_r(
        handle: GEOSContextHandle_t,
        newDims: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOS_getWKBByteOrder_r(handle: GEOSContextHandle_t) -> libc::c_int;
}
extern "C" {
    pub fn GEOS_setWKBByteOrder_r(
        handle: GEOSContextHandle_t,
        byteOrder: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeomFromWKB_buf_r(
        handle: GEOSContextHandle_t,
        wkb: *const libc::c_uchar,
        size: usize,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeomToWKB_buf_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        size: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn GEOSGeomFromHEX_buf_r(
        handle: GEOSContextHandle_t,
        hex: *const libc::c_uchar,
        size: usize,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeomToHEX_buf_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        size: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    #[doc = " Coordinate Sequence functions"]
    #[doc = ""]
    pub fn GEOSCoordSeq_create_r(
        handle: GEOSContextHandle_t,
        size: libc::c_uint,
        dims: libc::c_uint,
    ) -> *mut GEOSCoordSequence;
}
extern "C" {
    pub fn GEOSCoordSeq_clone_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
    ) -> *mut GEOSCoordSequence;
}
extern "C" {
    pub fn GEOSCoordSeq_destroy_r(handle: GEOSContextHandle_t, s: *mut GEOSCoordSequence);
}
extern "C" {
    pub fn GEOSCoordSeq_setX_r(
        handle: GEOSContextHandle_t,
        s: *mut GEOSCoordSequence,
        idx: libc::c_uint,
        val: f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_setY_r(
        handle: GEOSContextHandle_t,
        s: *mut GEOSCoordSequence,
        idx: libc::c_uint,
        val: f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_setZ_r(
        handle: GEOSContextHandle_t,
        s: *mut GEOSCoordSequence,
        idx: libc::c_uint,
        val: f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_setXY_r(
        handle: GEOSContextHandle_t,
        s: *mut GEOSCoordSequence,
        idx: libc::c_uint,
        x: f64,
        y: f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_setXYZ_r(
        handle: GEOSContextHandle_t,
        s: *mut GEOSCoordSequence,
        idx: libc::c_uint,
        x: f64,
        y: f64,
        z: f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_setOrdinate_r(
        handle: GEOSContextHandle_t,
        s: *mut GEOSCoordSequence,
        idx: libc::c_uint,
        dim: libc::c_uint,
        val: f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_getX_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        val: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_getY_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        val: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_getZ_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        val: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_getXY_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        x: *mut f64,
        y: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_getXYZ_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_getOrdinate_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        dim: libc::c_uint,
        val: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_getSize_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
        size: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_getDimensions_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
        dims: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_isCCW_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
        is_ccw: *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  Linear referencing functions -- there are more, but these are"]
    #[doc = "  probably sufficient for most purposes"]
    #[doc = ""]
    pub fn GEOSProject_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        p: *const GEOSGeometry,
    ) -> f64;
}
extern "C" {
    pub fn GEOSInterpolate_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        d: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSProjectNormalized_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        p: *const GEOSGeometry,
    ) -> f64;
}
extern "C" {
    pub fn GEOSInterpolateNormalized_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        d: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSBuffer_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        width: f64,
        quadsegs: libc::c_int,
    ) -> *mut GEOSGeometry;
}
pub const GEOSBufCapStyles_GEOSBUF_CAP_ROUND: GEOSBufCapStyles = 1;
pub const GEOSBufCapStyles_GEOSBUF_CAP_FLAT: GEOSBufCapStyles = 2;
pub const GEOSBufCapStyles_GEOSBUF_CAP_SQUARE: GEOSBufCapStyles = 3;
pub type GEOSBufCapStyles = libc::c_uint;
pub const GEOSBufJoinStyles_GEOSBUF_JOIN_ROUND: GEOSBufJoinStyles = 1;
pub const GEOSBufJoinStyles_GEOSBUF_JOIN_MITRE: GEOSBufJoinStyles = 2;
pub const GEOSBufJoinStyles_GEOSBUF_JOIN_BEVEL: GEOSBufJoinStyles = 3;
pub type GEOSBufJoinStyles = libc::c_uint;
extern "C" {
    pub fn GEOSBufferParams_create_r(handle: GEOSContextHandle_t) -> *mut GEOSBufferParams;
}
extern "C" {
    pub fn GEOSBufferParams_destroy_r(handle: GEOSContextHandle_t, parms: *mut GEOSBufferParams);
}
extern "C" {
    pub fn GEOSBufferParams_setEndCapStyle_r(
        handle: GEOSContextHandle_t,
        p: *mut GEOSBufferParams,
        style: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSBufferParams_setJoinStyle_r(
        handle: GEOSContextHandle_t,
        p: *mut GEOSBufferParams,
        joinStyle: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSBufferParams_setMitreLimit_r(
        handle: GEOSContextHandle_t,
        p: *mut GEOSBufferParams,
        mitreLimit: f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSBufferParams_setQuadrantSegments_r(
        handle: GEOSContextHandle_t,
        p: *mut GEOSBufferParams,
        quadSegs: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSBufferParams_setSingleSided_r(
        handle: GEOSContextHandle_t,
        p: *mut GEOSBufferParams,
        singleSided: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSBufferWithParams_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        p: *const GEOSBufferParams,
        width: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSBufferWithStyle_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        width: f64,
        quadsegs: libc::c_int,
        endCapStyle: libc::c_int,
        joinStyle: libc::c_int,
        mitreLimit: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSOffsetCurve_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        width: f64,
        quadsegs: libc::c_int,
        joinStyle: libc::c_int,
        mitreLimit: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Geometry Constructors."]
    #[doc = " GEOSCoordSequence* arguments will become ownership of the returned object."]
    #[doc = " All functions return NULL on exception."]
    #[doc = ""]
    pub fn GEOSGeom_createPoint_r(
        handle: GEOSContextHandle_t,
        s: *mut GEOSCoordSequence,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_createPointFromXY_r(
        handle: GEOSContextHandle_t,
        x: f64,
        y: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_createEmptyPoint_r(handle: GEOSContextHandle_t) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_createLinearRing_r(
        handle: GEOSContextHandle_t,
        s: *mut GEOSCoordSequence,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_createLineString_r(
        handle: GEOSContextHandle_t,
        s: *mut GEOSCoordSequence,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_createEmptyLineString_r(handle: GEOSContextHandle_t) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_createEmptyPolygon_r(handle: GEOSContextHandle_t) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_createPolygon_r(
        handle: GEOSContextHandle_t,
        shell: *mut GEOSGeometry,
        holes: *mut *mut GEOSGeometry,
        nholes: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_createCollection_r(
        handle: GEOSContextHandle_t,
        type_: libc::c_int,
        geoms: *mut *mut GEOSGeometry,
        ngeoms: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_createEmptyCollection_r(
        handle: GEOSContextHandle_t,
        type_: libc::c_int,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_clone_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Memory management"]
    #[doc = ""]
    pub fn GEOSGeom_destroy_r(handle: GEOSContextHandle_t, g: *mut GEOSGeometry);
}
extern "C" {
    #[doc = " Topology operations - return NULL on exception."]
    #[doc = ""]
    pub fn GEOSEnvelope_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry)
        -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSIntersection_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSIntersectionPrec_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        gridSize: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSConvexHull_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSMinimumRotatedRectangle_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSMaximumInscribedCircle_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        tolerance: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSLargestEmptyCircle_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        boundary: *const GEOSGeometry,
        tolerance: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSMinimumWidth_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSMinimumClearanceLine_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSMinimumClearance_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        distance: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSDifference_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSDifferencePrec_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        gridSize: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSSymDifference_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSSymDifferencePrec_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        gridSize: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSBoundary_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry)
        -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSUnion_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSUnionPrec_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        gridSize: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSUnaryUnion_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSUnaryUnionPrec_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        gridSize: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSCoverageUnion_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSPointOnSurface_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGetCentroid_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSMinimumBoundingCircle_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        radius: *mut f64,
        center: *mut *mut GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSNode_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSClipByRect_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        xmin: f64,
        ymin: f64,
        xmax: f64,
        ymax: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSPolygonize_r(
        handle: GEOSContextHandle_t,
        geoms: *const *const GEOSGeometry,
        ngeoms: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSPolygonize_valid_r(
        handle: GEOSContextHandle_t,
        geoms: *const *const GEOSGeometry,
        ngems: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSPolygonizer_getCutEdges_r(
        handle: GEOSContextHandle_t,
        geoms: *const *const GEOSGeometry,
        ngeoms: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSPolygonize_full_r(
        handle: GEOSContextHandle_t,
        input: *const GEOSGeometry,
        cuts: *mut *mut GEOSGeometry,
        dangles: *mut *mut GEOSGeometry,
        invalidRings: *mut *mut GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSBuildArea_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSLineMerge_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSReverse_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSSimplify_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        tolerance: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSTopologyPreserveSimplify_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        tolerance: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_extractUniquePoints_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSSharedPaths_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSSnap_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        tolerance: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSDelaunayTriangulation_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        tolerance: f64,
        onlyEdges: libc::c_int,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSVoronoiDiagram_r(
        extHandle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        env: *const GEOSGeometry,
        tolerance: f64,
        onlyEdges: libc::c_int,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSSegmentIntersection_r(
        extHandle: GEOSContextHandle_t,
        ax0: f64,
        ay0: f64,
        ax1: f64,
        ay1: f64,
        bx0: f64,
        by0: f64,
        bx1: f64,
        by1: f64,
        cx: *mut f64,
        cy: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  Binary predicates - return 2 on exception, 1 on true, 0 on false"]
    #[doc = ""]
    pub fn GEOSDisjoint_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSTouches_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSIntersects_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSCrosses_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSWithin_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSContains_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSOverlaps_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSEquals_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSEqualsExact_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        tolerance: f64,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSCovers_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSCoveredBy_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = "  Prepared Geometry Binary predicates - return 2 on exception, 1 on true, 0 on false"]
    #[doc = ""]
    pub fn GEOSPrepare_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *const GEOSPreparedGeometry;
}
extern "C" {
    pub fn GEOSPreparedGeom_destroy_r(handle: GEOSContextHandle_t, g: *const GEOSPreparedGeometry);
}
extern "C" {
    pub fn GEOSPreparedContains_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSPreparedContainsProperly_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSPreparedCoveredBy_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSPreparedCovers_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSPreparedCrosses_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSPreparedDisjoint_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSPreparedIntersects_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSPreparedOverlaps_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSPreparedTouches_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSPreparedWithin_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSPreparedNearestPoints_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> *mut GEOSCoordSequence;
}
extern "C" {
    pub fn GEOSPreparedDistance_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  STRtree functions"]
    #[doc = ""]
    pub fn GEOSSTRtree_create_r(
        handle: GEOSContextHandle_t,
        nodeCapacity: usize,
    ) -> *mut GEOSSTRtree;
}
extern "C" {
    pub fn GEOSSTRtree_insert_r(
        handle: GEOSContextHandle_t,
        tree: *mut GEOSSTRtree,
        g: *const GEOSGeometry,
        item: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GEOSSTRtree_query_r(
        handle: GEOSContextHandle_t,
        tree: *mut GEOSSTRtree,
        g: *const GEOSGeometry,
        callback: GEOSQueryCallback,
        userdata: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GEOSSTRtree_nearest_r(
        handle: GEOSContextHandle_t,
        tree: *mut GEOSSTRtree,
        geom: *const GEOSGeometry,
    ) -> *const GEOSGeometry;
}
extern "C" {
    pub fn GEOSSTRtree_nearest_generic_r(
        handle: GEOSContextHandle_t,
        tree: *mut GEOSSTRtree,
        item: *const libc::c_void,
        itemEnvelope: *const GEOSGeometry,
        distancefn: GEOSDistanceCallback,
        userdata: *mut libc::c_void,
    ) -> *const libc::c_void;
}
extern "C" {
    pub fn GEOSSTRtree_iterate_r(
        handle: GEOSContextHandle_t,
        tree: *mut GEOSSTRtree,
        callback: GEOSQueryCallback,
        userdata: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GEOSSTRtree_remove_r(
        handle: GEOSContextHandle_t,
        tree: *mut GEOSSTRtree,
        g: *const GEOSGeometry,
        item: *mut libc::c_void,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSSTRtree_destroy_r(handle: GEOSContextHandle_t, tree: *mut GEOSSTRtree);
}
extern "C" {
    #[doc = "  Unary predicate - return 2 on exception, 1 on true, 0 on false"]
    #[doc = ""]
    pub fn GEOSisEmpty_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    pub fn GEOSisSimple_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    pub fn GEOSisRing_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    pub fn GEOSHasZ_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    pub fn GEOSisClosed_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> libc::c_char;
}
pub const GEOSRelateBoundaryNodeRules_GEOSRELATE_BNR_MOD2: GEOSRelateBoundaryNodeRules = 1;
pub const GEOSRelateBoundaryNodeRules_GEOSRELATE_BNR_OGC: GEOSRelateBoundaryNodeRules = 1;
pub const GEOSRelateBoundaryNodeRules_GEOSRELATE_BNR_ENDPOINT: GEOSRelateBoundaryNodeRules = 2;
pub const GEOSRelateBoundaryNodeRules_GEOSRELATE_BNR_MULTIVALENT_ENDPOINT:
    GEOSRelateBoundaryNodeRules = 3;
pub const GEOSRelateBoundaryNodeRules_GEOSRELATE_BNR_MONOVALENT_ENDPOINT:
    GEOSRelateBoundaryNodeRules = 4;
#[doc = "  Dimensionally Extended 9 Intersection Model related"]
#[doc = ""]
pub type GEOSRelateBoundaryNodeRules = libc::c_uint;
extern "C" {
    pub fn GEOSRelatePattern_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        pat: *const libc::c_char,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSRelate_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn GEOSRelatePatternMatch_r(
        handle: GEOSContextHandle_t,
        mat: *const libc::c_char,
        pat: *const libc::c_char,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSRelateBoundaryNodeRule_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        bnr: libc::c_int,
    ) -> *mut libc::c_char;
}
pub const GEOSValidFlags_GEOSVALID_ALLOW_SELFTOUCHING_RING_FORMING_HOLE: GEOSValidFlags = 1;
#[doc = "  Validity checking"]
#[doc = ""]
pub type GEOSValidFlags = libc::c_uint;
extern "C" {
    pub fn GEOSisValid_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    pub fn GEOSisValidReason_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn GEOSisValidDetail_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        flags: libc::c_int,
        reason: *mut *mut libc::c_char,
        location: *mut *mut GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSMakeValid_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = "  Geometry info"]
    #[doc = ""]
    pub fn GEOSGeomType_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry)
        -> *mut libc::c_char;
}
extern "C" {
    pub fn GEOSGeomTypeId_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGetSRID_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> libc::c_int;
}
extern "C" {
    pub fn GEOSSetSRID_r(handle: GEOSContextHandle_t, g: *mut GEOSGeometry, SRID: libc::c_int);
}
extern "C" {
    pub fn GEOSGeom_getUserData_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GEOSGeom_setUserData_r(
        handle: GEOSContextHandle_t,
        g: *mut GEOSGeometry,
        userData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GEOSGetNumGeometries_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGetGeometryN_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        n: libc::c_int,
    ) -> *const GEOSGeometry;
}
extern "C" {
    pub fn GEOSNormalize_r(handle: GEOSContextHandle_t, g: *mut GEOSGeometry) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the geometry's precision, optionally rounding all its"]
    #[doc = " coordinates to the precision grid (if it changes)."]
    #[doc = ""]
    #[doc = " Note that operations will always be performed in the precision"]
    #[doc = " of the geometry with higher precision (smaller \"gridSize\")."]
    #[doc = " That same precision will be attached to the operation outputs."]
    #[doc = ""]
    #[doc = " @param gridSize size of the precision grid, or 0 for FLOATING"]
    #[doc = "                 precision."]
    #[doc = " @param flags The bitwise OR of one of more of the"]
    #[doc = "              @ref GEOS_PREC_NO_TOPO \"precision options\""]
    #[doc = " @retuns NULL on exception or a new GEOSGeometry object"]
    #[doc = ""]
    pub fn GEOSGeom_setPrecision_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        gridSize: f64,
        flags: libc::c_int,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Get a geometry's precision"]
    #[doc = ""]
    #[doc = " @return the size of the geometry's precision grid, 0 for FLOATING"]
    #[doc = "         precision or -1 on exception"]
    pub fn GEOSGeom_getPrecision_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> f64;
}
extern "C" {
    pub fn GEOSGetNumInteriorRings_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeomGetNumPoints_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeomGetX_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        x: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeomGetY_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        y: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeomGetZ_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        z: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGetInteriorRingN_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        n: libc::c_int,
    ) -> *const GEOSGeometry;
}
extern "C" {
    pub fn GEOSGetExteriorRing_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *const GEOSGeometry;
}
extern "C" {
    pub fn GEOSGetNumCoordinates_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeom_getCoordSeq_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *const GEOSCoordSequence;
}
extern "C" {
    pub fn GEOSGeom_getDimensions_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeom_getCoordinateDimension_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeom_getXMin_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        value: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeom_getYMin_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        value: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeom_getXMax_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        value: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeom_getYMax_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        value: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeomGetPointN_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        n: libc::c_int,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeomGetStartPoint_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeomGetEndPoint_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = "  Misc functions"]
    #[doc = ""]
    pub fn GEOSArea_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        area: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSLength_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        length: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSDistance_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSDistanceIndexed_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSHausdorffDistance_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSHausdorffDistanceDensify_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        densifyFrac: f64,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSFrechetDistance_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSFrechetDistanceDensify_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        densifyFrac: f64,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeomGetLength_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        length: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSNearestPoints_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> *mut GEOSCoordSequence;
}
extern "C" {
    #[doc = " Algorithms"]
    #[doc = ""]
    pub fn GEOSOrientationIndex_r(
        handle: GEOSContextHandle_t,
        Ax: f64,
        Ay: f64,
        Bx: f64,
        By: f64,
        Px: f64,
        Py: f64,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSWKTReader_t {
    _unused: [u8; 0],
}
pub type GEOSWKTReader = GEOSWKTReader_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSWKTWriter_t {
    _unused: [u8; 0],
}
pub type GEOSWKTWriter = GEOSWKTWriter_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSWKBReader_t {
    _unused: [u8; 0],
}
pub type GEOSWKBReader = GEOSWKBReader_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSWKBWriter_t {
    _unused: [u8; 0],
}
pub type GEOSWKBWriter = GEOSWKBWriter_t;
extern "C" {
    pub fn GEOSWKTReader_create_r(handle: GEOSContextHandle_t) -> *mut GEOSWKTReader;
}
extern "C" {
    pub fn GEOSWKTReader_destroy_r(handle: GEOSContextHandle_t, reader: *mut GEOSWKTReader);
}
extern "C" {
    pub fn GEOSWKTReader_read_r(
        handle: GEOSContextHandle_t,
        reader: *mut GEOSWKTReader,
        wkt: *const libc::c_char,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSWKTWriter_create_r(handle: GEOSContextHandle_t) -> *mut GEOSWKTWriter;
}
extern "C" {
    pub fn GEOSWKTWriter_destroy_r(handle: GEOSContextHandle_t, writer: *mut GEOSWKTWriter);
}
extern "C" {
    pub fn GEOSWKTWriter_write_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKTWriter,
        g: *const GEOSGeometry,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn GEOSWKTWriter_setTrim_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKTWriter,
        trim: libc::c_char,
    );
}
extern "C" {
    pub fn GEOSWKTWriter_setRoundingPrecision_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKTWriter,
        precision: libc::c_int,
    );
}
extern "C" {
    pub fn GEOSWKTWriter_setOutputDimension_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKTWriter,
        dim: libc::c_int,
    );
}
extern "C" {
    pub fn GEOSWKTWriter_getOutputDimension_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKTWriter,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSWKTWriter_setOld3D_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKTWriter,
        useOld3D: libc::c_int,
    );
}
extern "C" {
    pub fn GEOSWKBReader_create_r(handle: GEOSContextHandle_t) -> *mut GEOSWKBReader;
}
extern "C" {
    pub fn GEOSWKBReader_destroy_r(handle: GEOSContextHandle_t, reader: *mut GEOSWKBReader);
}
extern "C" {
    pub fn GEOSWKBReader_read_r(
        handle: GEOSContextHandle_t,
        reader: *mut GEOSWKBReader,
        wkb: *const libc::c_uchar,
        size: usize,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSWKBReader_readHEX_r(
        handle: GEOSContextHandle_t,
        reader: *mut GEOSWKBReader,
        hex: *const libc::c_uchar,
        size: usize,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSWKBWriter_create_r(handle: GEOSContextHandle_t) -> *mut GEOSWKBWriter;
}
extern "C" {
    pub fn GEOSWKBWriter_destroy_r(handle: GEOSContextHandle_t, writer: *mut GEOSWKBWriter);
}
extern "C" {
    pub fn GEOSWKBWriter_write_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKBWriter,
        g: *const GEOSGeometry,
        size: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn GEOSWKBWriter_writeHEX_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKBWriter,
        g: *const GEOSGeometry,
        size: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn GEOSWKBWriter_getOutputDimension_r(
        handle: GEOSContextHandle_t,
        writer: *const GEOSWKBWriter,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSWKBWriter_setOutputDimension_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKBWriter,
        newDimension: libc::c_int,
    );
}
extern "C" {
    pub fn GEOSWKBWriter_getByteOrder_r(
        handle: GEOSContextHandle_t,
        writer: *const GEOSWKBWriter,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSWKBWriter_setByteOrder_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKBWriter,
        byteOrder: libc::c_int,
    );
}
extern "C" {
    pub fn GEOSWKBWriter_getIncludeSRID_r(
        handle: GEOSContextHandle_t,
        writer: *const GEOSWKBWriter,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSWKBWriter_setIncludeSRID_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKBWriter,
        writeSRID: libc::c_char,
    );
}
extern "C" {
    pub fn GEOSFree_r(handle: GEOSContextHandle_t, buffer: *mut libc::c_void);
}
extern "C" {
    pub fn GEOS_getWKBOutputDims() -> libc::c_int;
}
extern "C" {
    pub fn GEOS_setWKBOutputDims(newDims: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn GEOS_getWKBByteOrder() -> libc::c_int;
}
extern "C" {
    pub fn GEOS_setWKBByteOrder(byteOrder: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeomFromWKB_buf(wkb: *const libc::c_uchar, size: usize) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeomToWKB_buf(g: *const GEOSGeometry, size: *mut usize) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn GEOSGeomFromHEX_buf(hex: *const libc::c_uchar, size: usize) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeomToHEX_buf(g: *const GEOSGeometry, size: *mut usize) -> *mut libc::c_uchar;
}
extern "C" {
    #[doc = " Coordinate Sequence functions"]
    #[doc = ""]
    pub fn GEOSCoordSeq_create(size: libc::c_uint, dims: libc::c_uint) -> *mut GEOSCoordSequence;
}
extern "C" {
    pub fn GEOSCoordSeq_clone(s: *const GEOSCoordSequence) -> *mut GEOSCoordSequence;
}
extern "C" {
    pub fn GEOSCoordSeq_destroy(s: *mut GEOSCoordSequence);
}
extern "C" {
    pub fn GEOSCoordSeq_setX(s: *mut GEOSCoordSequence, idx: libc::c_uint, val: f64)
        -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_setY(s: *mut GEOSCoordSequence, idx: libc::c_uint, val: f64)
        -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_setZ(s: *mut GEOSCoordSequence, idx: libc::c_uint, val: f64)
        -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_setXY(
        s: *mut GEOSCoordSequence,
        idx: libc::c_uint,
        x: f64,
        y: f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_setXYZ(
        s: *mut GEOSCoordSequence,
        idx: libc::c_uint,
        x: f64,
        y: f64,
        z: f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_setOrdinate(
        s: *mut GEOSCoordSequence,
        idx: libc::c_uint,
        dim: libc::c_uint,
        val: f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_getX(
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        val: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_getY(
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        val: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_getZ(
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        val: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_getXY(
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        x: *mut f64,
        y: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_getXYZ(
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_getOrdinate(
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        dim: libc::c_uint,
        val: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_getSize(
        s: *const GEOSCoordSequence,
        size: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_getDimensions(
        s: *const GEOSCoordSequence,
        dims: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSCoordSeq_isCCW(
        s: *const GEOSCoordSequence,
        is_ccw: *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  Linear referencing functions -- there are more, but these are"]
    #[doc = "  probably sufficient for most purposes"]
    #[doc = ""]
    pub fn GEOSProject(g: *const GEOSGeometry, p: *const GEOSGeometry) -> f64;
}
extern "C" {
    pub fn GEOSInterpolate(g: *const GEOSGeometry, d: f64) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSProjectNormalized(g: *const GEOSGeometry, p: *const GEOSGeometry) -> f64;
}
extern "C" {
    pub fn GEOSInterpolateNormalized(g: *const GEOSGeometry, d: f64) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSBuffer(
        g: *const GEOSGeometry,
        width: f64,
        quadsegs: libc::c_int,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSBufferParams_create() -> *mut GEOSBufferParams;
}
extern "C" {
    pub fn GEOSBufferParams_destroy(parms: *mut GEOSBufferParams);
}
extern "C" {
    pub fn GEOSBufferParams_setEndCapStyle(
        p: *mut GEOSBufferParams,
        style: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSBufferParams_setJoinStyle(
        p: *mut GEOSBufferParams,
        joinStyle: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSBufferParams_setMitreLimit(p: *mut GEOSBufferParams, mitreLimit: f64)
        -> libc::c_int;
}
extern "C" {
    pub fn GEOSBufferParams_setQuadrantSegments(
        p: *mut GEOSBufferParams,
        quadSegs: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSBufferParams_setSingleSided(
        p: *mut GEOSBufferParams,
        singleSided: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSBufferWithParams(
        g: *const GEOSGeometry,
        p: *const GEOSBufferParams,
        width: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSBufferWithStyle(
        g: *const GEOSGeometry,
        width: f64,
        quadsegs: libc::c_int,
        endCapStyle: libc::c_int,
        joinStyle: libc::c_int,
        mitreLimit: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSOffsetCurve(
        g: *const GEOSGeometry,
        width: f64,
        quadsegs: libc::c_int,
        joinStyle: libc::c_int,
        mitreLimit: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Geometry Constructors."]
    #[doc = " GEOSCoordSequence* arguments will become ownership of the returned object."]
    #[doc = " All functions return NULL on exception."]
    #[doc = ""]
    pub fn GEOSGeom_createPoint(s: *mut GEOSCoordSequence) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_createPointFromXY(x: f64, y: f64) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_createEmptyPoint() -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_createLinearRing(s: *mut GEOSCoordSequence) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_createLineString(s: *mut GEOSCoordSequence) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_createEmptyLineString() -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_createEmptyPolygon() -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_createPolygon(
        shell: *mut GEOSGeometry,
        holes: *mut *mut GEOSGeometry,
        nholes: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_createCollection(
        type_: libc::c_int,
        geoms: *mut *mut GEOSGeometry,
        ngeoms: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_createEmptyCollection(type_: libc::c_int) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_clone(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Memory management"]
    #[doc = ""]
    pub fn GEOSGeom_destroy(g: *mut GEOSGeometry);
}
extern "C" {
    #[doc = " Topology operations - return NULL on exception."]
    #[doc = ""]
    pub fn GEOSEnvelope(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSIntersection(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSIntersectionPrec(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        gridSize: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSConvexHull(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSMinimumRotatedRectangle(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSMaximumInscribedCircle(g: *const GEOSGeometry, tolerance: f64) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSLargestEmptyCircle(
        g: *const GEOSGeometry,
        boundary: *const GEOSGeometry,
        tolerance: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSMinimumWidth(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSMinimumClearance(g: *const GEOSGeometry, d: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn GEOSMinimumClearanceLine(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSDifference(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSDifferencePrec(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        gridSize: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSSymDifference(g1: *const GEOSGeometry, g2: *const GEOSGeometry)
        -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSSymDifferencePrec(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        gridSize: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSBoundary(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSUnion(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSUnionPrec(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        gridSize: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSUnaryUnion(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSUnaryUnionPrec(g: *const GEOSGeometry, gridSize: f64) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSCoverageUnion(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSPointOnSurface(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGetCentroid(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSMinimumBoundingCircle(
        g: *const GEOSGeometry,
        radius: *mut f64,
        center: *mut *mut GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSNode(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSClipByRect(
        g: *const GEOSGeometry,
        xmin: f64,
        ymin: f64,
        xmax: f64,
        ymax: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSPolygonize(
        geoms: *const *const GEOSGeometry,
        ngeoms: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSPolygonize_valid(
        geoms: *const *const GEOSGeometry,
        ngeoms: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSPolygonizer_getCutEdges(
        geoms: *const *const GEOSGeometry,
        ngeoms: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSPolygonize_full(
        input: *const GEOSGeometry,
        cuts: *mut *mut GEOSGeometry,
        dangles: *mut *mut GEOSGeometry,
        invalid: *mut *mut GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSBuildArea(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSLineMerge(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSReverse(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSSimplify(g: *const GEOSGeometry, tolerance: f64) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSTopologyPreserveSimplify(
        g: *const GEOSGeometry,
        tolerance: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_extractUniquePoints(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSSharedPaths(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSSnap(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        tolerance: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSDelaunayTriangulation(
        g: *const GEOSGeometry,
        tolerance: f64,
        onlyEdges: libc::c_int,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSVoronoiDiagram(
        g: *const GEOSGeometry,
        env: *const GEOSGeometry,
        tolerance: f64,
        onlyEdges: libc::c_int,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSSegmentIntersection(
        ax0: f64,
        ay0: f64,
        ax1: f64,
        ay1: f64,
        bx0: f64,
        by0: f64,
        bx1: f64,
        by1: f64,
        cx: *mut f64,
        cy: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  Binary predicates - return 2 on exception, 1 on true, 0 on false"]
    #[doc = ""]
    pub fn GEOSDisjoint(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    pub fn GEOSTouches(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    pub fn GEOSIntersects(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    pub fn GEOSCrosses(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    pub fn GEOSWithin(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    pub fn GEOSContains(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    pub fn GEOSOverlaps(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    pub fn GEOSEquals(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    pub fn GEOSCovers(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    pub fn GEOSCoveredBy(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " Determine pointwise equivalence of two geometries, by checking if each vertex of g2 is"]
    #[doc = " within tolerance of the corresponding vertex in g1."]
    #[doc = " Unlike GEOSEquals, geometries that are topologically equivalent but have different"]
    #[doc = " representations (e.g., LINESTRING (0 0, 1 1) and MULTILINESTRING ((0 0, 1 1)) ) are not"]
    #[doc = " considered equivalent by GEOSEqualsExact."]
    #[doc = " returns 2 on exception, 1 on true, 0 on false"]
    pub fn GEOSEqualsExact(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        tolerance: f64,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = "  Prepared Geometry Binary predicates - return 2 on exception, 1 on true, 0 on false"]
    #[doc = ""]
    pub fn GEOSPrepare(g: *const GEOSGeometry) -> *const GEOSPreparedGeometry;
}
extern "C" {
    pub fn GEOSPreparedGeom_destroy(g: *const GEOSPreparedGeometry);
}
extern "C" {
    pub fn GEOSPreparedContains(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSPreparedContainsProperly(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSPreparedCoveredBy(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSPreparedCovers(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSPreparedCrosses(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSPreparedDisjoint(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSPreparedIntersects(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSPreparedOverlaps(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSPreparedTouches(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSPreparedWithin(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSPreparedNearestPoints(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> *mut GEOSCoordSequence;
}
extern "C" {
    pub fn GEOSPreparedDistance(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSSTRtree_create(nodeCapacity: usize) -> *mut GEOSSTRtree;
}
extern "C" {
    pub fn GEOSSTRtree_insert(
        tree: *mut GEOSSTRtree,
        g: *const GEOSGeometry,
        item: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GEOSSTRtree_query(
        tree: *mut GEOSSTRtree,
        g: *const GEOSGeometry,
        callback: GEOSQueryCallback,
        userdata: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GEOSSTRtree_nearest(
        tree: *mut GEOSSTRtree,
        geom: *const GEOSGeometry,
    ) -> *const GEOSGeometry;
}
extern "C" {
    pub fn GEOSSTRtree_nearest_generic(
        tree: *mut GEOSSTRtree,
        item: *const libc::c_void,
        itemEnvelope: *const GEOSGeometry,
        distancefn: GEOSDistanceCallback,
        userdata: *mut libc::c_void,
    ) -> *const libc::c_void;
}
extern "C" {
    pub fn GEOSSTRtree_iterate(
        tree: *mut GEOSSTRtree,
        callback: GEOSQueryCallback,
        userdata: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GEOSSTRtree_remove(
        tree: *mut GEOSSTRtree,
        g: *const GEOSGeometry,
        item: *mut libc::c_void,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSSTRtree_destroy(tree: *mut GEOSSTRtree);
}
extern "C" {
    #[doc = "  Unary predicate - return 2 on exception, 1 on true, 0 on false"]
    #[doc = ""]
    pub fn GEOSisEmpty(g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    pub fn GEOSisSimple(g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    pub fn GEOSisRing(g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    pub fn GEOSHasZ(g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    pub fn GEOSisClosed(g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = "  Dimensionally Extended 9 Intersection Model related"]
    #[doc = ""]
    pub fn GEOSRelatePattern(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        pat: *const libc::c_char,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSRelate(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> *mut libc::c_char;
}
extern "C" {
    pub fn GEOSRelatePatternMatch(
        mat: *const libc::c_char,
        pat: *const libc::c_char,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSRelateBoundaryNodeRule(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        bnr: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = "  Validity checking"]
    #[doc = ""]
    pub fn GEOSisValid(g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    pub fn GEOSisValidReason(g: *const GEOSGeometry) -> *mut libc::c_char;
}
extern "C" {
    pub fn GEOSisValidDetail(
        g: *const GEOSGeometry,
        flags: libc::c_int,
        reason: *mut *mut libc::c_char,
        location: *mut *mut GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    pub fn GEOSMakeValid(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = "  Geometry info"]
    #[doc = ""]
    pub fn GEOSGeomType(g: *const GEOSGeometry) -> *mut libc::c_char;
}
extern "C" {
    pub fn GEOSGeomTypeId(g: *const GEOSGeometry) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGetSRID(g: *const GEOSGeometry) -> libc::c_int;
}
extern "C" {
    pub fn GEOSSetSRID(g: *mut GEOSGeometry, SRID: libc::c_int);
}
extern "C" {
    pub fn GEOSGeom_getUserData(g: *const GEOSGeometry) -> *mut libc::c_void;
}
extern "C" {
    pub fn GEOSGeom_setUserData(g: *mut GEOSGeometry, userData: *mut libc::c_void);
}
extern "C" {
    pub fn GEOSGetNumGeometries(g: *const GEOSGeometry) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGetGeometryN(g: *const GEOSGeometry, n: libc::c_int) -> *const GEOSGeometry;
}
extern "C" {
    pub fn GEOSNormalize(g: *mut GEOSGeometry) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeom_setPrecision(
        g: *const GEOSGeometry,
        gridSize: f64,
        flags: libc::c_int,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeom_getPrecision(g: *const GEOSGeometry) -> f64;
}
extern "C" {
    pub fn GEOSGetNumInteriorRings(g: *const GEOSGeometry) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeomGetNumPoints(g: *const GEOSGeometry) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeomGetX(g: *const GEOSGeometry, x: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeomGetY(g: *const GEOSGeometry, y: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeomGetZ(g: *const GEOSGeometry, z: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGetInteriorRingN(g: *const GEOSGeometry, n: libc::c_int) -> *const GEOSGeometry;
}
extern "C" {
    pub fn GEOSGetExteriorRing(g: *const GEOSGeometry) -> *const GEOSGeometry;
}
extern "C" {
    pub fn GEOSGetNumCoordinates(g: *const GEOSGeometry) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeom_getCoordSeq(g: *const GEOSGeometry) -> *const GEOSCoordSequence;
}
extern "C" {
    pub fn GEOSGeom_getDimensions(g: *const GEOSGeometry) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeom_getCoordinateDimension(g: *const GEOSGeometry) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeom_getXMin(g: *const GEOSGeometry, value: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeom_getYMin(g: *const GEOSGeometry, value: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeom_getXMax(g: *const GEOSGeometry, value: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeom_getYMax(g: *const GEOSGeometry, value: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeomGetPointN(g: *const GEOSGeometry, n: libc::c_int) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeomGetStartPoint(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSGeomGetEndPoint(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = "  Misc functions"]
    #[doc = ""]
    pub fn GEOSArea(g: *const GEOSGeometry, area: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn GEOSLength(g: *const GEOSGeometry, length: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn GEOSDistance(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSDistanceIndexed(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSHausdorffDistance(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSHausdorffDistanceDensify(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        densifyFrac: f64,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSFrechetDistance(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSFrechetDistanceDensify(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        densifyFrac: f64,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GEOSGeomGetLength(g: *const GEOSGeometry, length: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn GEOSNearestPoints(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> *mut GEOSCoordSequence;
}
extern "C" {
    #[doc = " Algorithms"]
    #[doc = ""]
    pub fn GEOSOrientationIndex(
        Ax: f64,
        Ay: f64,
        Bx: f64,
        By: f64,
        Px: f64,
        Py: f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Reader and Writer APIs"]
    #[doc = ""]
    pub fn GEOSWKTReader_create() -> *mut GEOSWKTReader;
}
extern "C" {
    pub fn GEOSWKTReader_destroy(reader: *mut GEOSWKTReader);
}
extern "C" {
    pub fn GEOSWKTReader_read(
        reader: *mut GEOSWKTReader,
        wkt: *const libc::c_char,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSWKTWriter_create() -> *mut GEOSWKTWriter;
}
extern "C" {
    pub fn GEOSWKTWriter_destroy(writer: *mut GEOSWKTWriter);
}
extern "C" {
    pub fn GEOSWKTWriter_write(
        writer: *mut GEOSWKTWriter,
        g: *const GEOSGeometry,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn GEOSWKTWriter_setTrim(writer: *mut GEOSWKTWriter, trim: libc::c_char);
}
extern "C" {
    pub fn GEOSWKTWriter_setRoundingPrecision(writer: *mut GEOSWKTWriter, precision: libc::c_int);
}
extern "C" {
    pub fn GEOSWKTWriter_setOutputDimension(writer: *mut GEOSWKTWriter, dim: libc::c_int);
}
extern "C" {
    pub fn GEOSWKTWriter_getOutputDimension(writer: *mut GEOSWKTWriter) -> libc::c_int;
}
extern "C" {
    pub fn GEOSWKTWriter_setOld3D(writer: *mut GEOSWKTWriter, useOld3D: libc::c_int);
}
extern "C" {
    pub fn GEOSWKBReader_create() -> *mut GEOSWKBReader;
}
extern "C" {
    pub fn GEOSWKBReader_destroy(reader: *mut GEOSWKBReader);
}
extern "C" {
    pub fn GEOSWKBReader_read(
        reader: *mut GEOSWKBReader,
        wkb: *const libc::c_uchar,
        size: usize,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSWKBReader_readHEX(
        reader: *mut GEOSWKBReader,
        hex: *const libc::c_uchar,
        size: usize,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    pub fn GEOSWKBWriter_create() -> *mut GEOSWKBWriter;
}
extern "C" {
    pub fn GEOSWKBWriter_destroy(writer: *mut GEOSWKBWriter);
}
extern "C" {
    pub fn GEOSWKBWriter_write(
        writer: *mut GEOSWKBWriter,
        g: *const GEOSGeometry,
        size: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn GEOSWKBWriter_writeHEX(
        writer: *mut GEOSWKBWriter,
        g: *const GEOSGeometry,
        size: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn GEOSWKBWriter_getOutputDimension(writer: *const GEOSWKBWriter) -> libc::c_int;
}
extern "C" {
    pub fn GEOSWKBWriter_setOutputDimension(writer: *mut GEOSWKBWriter, newDimension: libc::c_int);
}
extern "C" {
    pub fn GEOSWKBWriter_getByteOrder(writer: *const GEOSWKBWriter) -> libc::c_int;
}
extern "C" {
    pub fn GEOSWKBWriter_setByteOrder(writer: *mut GEOSWKBWriter, byteOrder: libc::c_int);
}
extern "C" {
    pub fn GEOSWKBWriter_getIncludeSRID(writer: *const GEOSWKBWriter) -> libc::c_char;
}
extern "C" {
    pub fn GEOSWKBWriter_setIncludeSRID(writer: *mut GEOSWKBWriter, writeSRID: libc::c_char);
}
extern "C" {
    pub fn GEOSFree(buffer: *mut libc::c_void);
}
